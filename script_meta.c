#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <stdlib.h> \n#include <unistd.h>\n\n#define RESET   "\033[0m"\n#define RED     "\033[1;31m"\n#define GREEN   "\033[1;32m"\n#define YELLOW  "\033[1;33m"\n#define BLUE    "\033[1;34m"\n#define PURPLE  "\033[1;35m"\n#define WHITE   "\033[1;37m"\n\n/*int\t\tgo_sound(char *command)\n{\n\tint\t\tstatus;\n\n\tstatus = 0;\n\tstatus = system(command);\n\treturn (status);\n}\n\nvoid\ttake_sound()\n{\n\t\tif (mf == NULL)\n\t\t\tgo_sound("afplay Adam_Farnell_Harry_Potter_Dubstep.mp3 &");\n}        */  \n\nint\t\t\tft_isspace(char c)\n{\n\treturn (c == '~');\n}\n\nint\t\tcount_words(char *str)\n{\n\tint\tcount;\n\n\tcount = 0;\n\twhile (*str)\n\t{\n\t\twhile (*str && ft_isspace(*str))\n\t\t\tstr++;\n\t\tif (*str && !ft_isspace(*str))\n\t\t{\n\t\t\tcount++;\n\t\t\twhile (*str && !ft_isspace(*str))\n\t\t\t\tstr++;\n\t\t}\n\t}\n\treturn (count);\n}\n\nchar\t*malloc_word(char *str)\n{\n\tchar *word;\n\tint\ti;\n\n\ti = 0;\n\twhile (str[i] && !ft_isspace(str[i]))\n\t\ti++;\n\tword = (char *)malloc(sizeof(char) * (i + 1));\n\ti = 0;\n\twhile (str[i] && !ft_isspace(str[i]))\n\t{\n\t\tword[i] = str[i];\n\t\ti++;\n\t}\n\tword[i] = '\0';\n\treturn (word);\n}\n\nchar\t**ft_split(char *str)\n{\n\tchar **arr = (char **)malloc(sizeof(char *) * (count_words(str) + 1));\n\n\tint i = 0;\n\twhile (*str)\n\t{\n\t\twhile (*str && ft_isspace(*str))\n\t\t\tstr++;\n\t\tif (*str && !ft_isspace(*str))\n\t\t{\n\t\t\tarr[i] = malloc_word(str);\n\t\t\ti++;\n\t\t\twhile (*str && !ft_isspace(*str))\n\t\t\t\tstr++;\n\t\t}\n\t}\n\tarr[i] = NULL;\n\treturn (arr);\n}\n\nchar* concat(char *s1, char *s2) {\n\n        size_t len1 = strlen(s1);\n        size_t len2 = strlen(s2);                      \n\n        char *result = malloc(len1 + len2 + 1);\n\n        if (!result) {\n            fprintf(stderr, "malloc() failed: insufficient memory!\n");\n            return NULL;\n        }\n\n        memcpy(result, s1, len1);\n        memcpy(result + len1, s2, len2 + 1);    \n\n        return result;\n    }\n\n/*int pusher (char * comment)\n{\n    if (comment[0] != '\0')\n    {\n        system("cd ~/rendu");\n        system("git commit -a -m \" ");\n    }\n}*/\n\nint opener(char *header, char *fill)\n{\n\tFILE *mf;\n    FILE *mh;\n\tint fp;\n    char *HOME = getenv("HOME");\n    char *rendu = "./rendu";\n    chdir (HOME);\n    chdir (rendu);\n    char *dot_c = ".c";\n    char *header_c = concat(header, dot_c);\n    char * check1 = "ft_list_foreach";\n    char * check2 = "ft_list_size";\n    char * check3 = "ft_list_remove_if";\n\tif (mkdir(header, 0777) == 0)\n    {\n        printf("\n\n%sDirectory %s was successfully created!%s", GREEN, header, RESET);\n        chdir (header);\n        fp = creat(header_c, 0777);\n\n\t    if (fp == -1)\n            printf("%sI can't create file!\n%s", RED, RESET);\n        else\n        {\n\t        printf ("%s\nCreating a Maradeur\'s  Map%s", YELLOW, RESET);\n\t        mf = fopen (header_c, "w");\n            free (header_c);\n\n\t        if (mf == NULL) \n                printf ("%s\nWRONG!\n%s", RED, RESET);\n\t        else \n                printf ("%s...\n%s", YELLOW, RESET);\n\n\n\t        fprintf(mf,"%s", fill);\n\t        printf("%sSucces! Map is created!\n\n", GREEN);\n\n            if (strcmp(header, check1) == 0 || strcmp(header, check2) == 0 || strcmp(header, check3) == 0)\n            {\n                fp = creat("ft_list.h", 0777);\n                mh = fopen ("ft_list.h", "w");\n                fprintf(mh, "#ifndef FT_LIST_H\n# define FT_LIST_H\n\ntypedef struct\ts_list\n{\n\tstruct s_list\t*next;\n\tvoid\t\t\t*data;\n}\t\t\t\tt_list;\n\n#endif\n");\n                fclose (mh);\n            }\n\n\t        fclose (mf);\n\t        printf ("Mischief managed!\n\n%s", RESET);\n        }\n    }\n    else\n    {\n        printf("\n\n%sI can't create a directory!\n%s", RED, RESET);\n    }\n    return (0);\n}\n\nint main (int argc, char   **argv)\n{\n    char *password = "mischief";\n    int level;\n    int  number_of_task = 0;\n    char **headers;\n    char **text_arr;\n    char *text;\n    int counter_of_tasks = 0;\n    int counter_of_prints = -1;\n    char *name;\n\n    if (argc != 2 || strcmp(argv[1], password) != 0)\n        printf("permission denied: %s\n", argv[0]);\n    else\n    {\n        printf("%s\n\n\t              _            _.,----,\n", PURPLE);\n        printf("\t   __  _.-._ / \'-.        -  ,._  \\)\n") ;\n        printf("\t  |  `-)_   \'-.   \\       / < _ )/\" }\n");\n        printf("\t  /__    \'-.   \\   \'-, ___(c-(6)=(6)%s                                                Messrs. %sStranger%s and %sShadow%s, purveyors of aids\n", RED, BLUE, RED, BLUE, RED);\n        printf("%s\t   , `\'.    `._ \'.  _,\'   >\\    \"  )%s                                               to magical mischief-makers, are proud to present\n", PURPLE, RED);\n        printf("%s\t   :;;,,\'-._   \'---\' (  ( \"/`. -=\'/%s       pizdec jmihnulo\n", PURPLE, YELLOW);\n        printf("%s\t  ;:;;:;;,  \'..__    ,`-.`)\'- \'--\'\n", PURPLE);\n        printf("\t  ;\';:;;;;;\'-._ /\'._|   Y/   _/\' \\%s                                                               THE MARADEUR\'S MAP!\n", RED);\n        printf("%s\t        \'\'\'\"._ F    |  _/ _.\'._   `\\                                                         NEW EXAM 42 IS COMING SOON!\n", PURPLE);\n        printf("\t               L    \\   \\/     '._  \\\n");\n        printf("\t        .-,-,_ |     `.  `\'---,  \\_ _|\n");\n        printf("\t        //    \'L    /  \\,   (\"--\',=`)7\n");\n        printf("\t       | `._       : _,  \\ /\'`-._L,_\'-._\n");\n        printf("\t       \'--\' \'-.\\__/ _L   .`'         \'.//\n");\n        printf("\t                   [ (  /\n");\n        printf("\t                    ) `{\n");\n        printf("\t                    \\__)\n\n\n%s", RESET);\n        printf("Please, input your current level of exam:\n\n %s0%s - for level 00\n %s1%s - for level 01\n %s2%s - for level 02\n %s3%s - for level 03\n %s4%s - for level 04\n %s5%s - for level 05\n\n\nAnd your input is ", YELLOW, RESET, YELLOW, RESET, YELLOW, RESET, YELLOW, RESET, YELLOW, RESET, YELLOW, RESET);\n        scanf("%d", &level);\n        printf("\n\n");\n\n        if (level == 0)\n        {           \n            headers = ft_split("aff_a~ft_countdown~ft_print_numbers~hello~maff_alpha~aff_first_param~aff_last_param~maff_revalpha~only_a~only_z~aff_z");\n            \n            counter_of_tasks = 10;\n            while (counter_of_prints++ != counter_of_tasks)\n                printf("%s%d.%s %s\n", YELLOW, counter_of_prints + 1, RESET, headers[counter_of_prints]);\n            printf("\n\nAnd your input is ");\n            scanf("%d", &number_of_task);    \n            text_arr = ft_split("~#include <unistd.h>\n\nint\t\tmain(int argc, char **argv)\n{\n\tif (argc != 2)\n\t\twrite(1, \"a\", 1);\n\telse\n\t{\n\t\twhile (*argv[1])\n\t\t{\n\t\t\tif (*argv[1] == 'a')\n\t\t\t{\n\t\t\t\twrite(1, \"a\", 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\targv[1]++;\n\t\t}\n\t}\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n\n~#include <unistd.h>\n\nint\t\tmain(void)\n{\n\tchar c;\n\n\tc = '9';\n\twhile (c >= '0')\n\t{\n\t\twrite(1, &c, 1);\n\t\tc--;\n\t}\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n\n~#include <unistd.h>\n\nvoid    ft_print_numbers(void)\n{\n    char nb;\n\n    nb = '0';\n    while (nb <= '9')\n    {\n        write(1, &nb, 1);\n        nb++;\n    }\n}\n\n~#include <unistd.h>\n\nint\t\tmain(void)\n{\n\twrite(1, \"Hello World!\\n\", 13);\n\treturn (0);\n}\n\n~#include <unistd.h>\n\nint\t\tmain(void)\n{\n\twrite(1, \"aBcDeFgHiJkLmNoPqRsTuVwXyZ\\n\", 27);\n\treturn (0);\n}\n\n~#include <unistd.h>\n\nint\t\tmain(int ac, char **av)\n{\n\tif (ac > 1)\n\t\twhile (*av[1])\n\t\t\twrite(1, av[1]++, 1);\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n\n~#include <unistd.h>\n\nint\t\tmain(int ac, char **av)\n{\n\tif (ac > 1)\n\t\twhile (*av[ac - 1])\n\t\t\twrite(1, av[ac - 1]++, 1);\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n\n~#include <unistd.h>\n\nvoid\tft_putchar(char c)\n{\n\twrite(1, &c, 1);\n}\n\nint\t\tmain(void)\n{\n\tint i;\n\n\ti = 123;\n\twhile (i-- > 97)\n\t\t(i \\% 2 == 0) ? ft_putchar(i) : ft_putchar(i - 32);\n\tft_putchar('\\n');;\n\treturn (0);\n}\n\n~#include <unistd.h>\n\nint\t\tmain(void)\n{\n\twrite(1, \"a\", 1);\n\treturn (0);\n}\n\n~#include <unistd.h>\n\nint\t\tmain(void)\n{\n\twrite(1, \"z\", 1);\n\treturn (0);\n}\n\n~#include <unistd.h>\n\nint\t\tmain(void)\n{\n\twrite(1, \"z\", 1);\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}");\n            text = text_arr[number_of_task - 1];\n            name = headers[number_of_task - 1];\n            opener(name, text);\n        }\n        else if (level == 1)\n        {\n            headers = ft_split("ft_strcpy~ft_strlen~repeat_alpha~search_and_replace~ulstr~rot13~first_word~ft_putstr~ft_swap~rev_print~rotone");\n\n            counter_of_tasks = 10;\n            while (counter_of_prints++ != counter_of_tasks)\n                printf("%s%d.%s %s\n", YELLOW, counter_of_prints + 1, RESET, headers[counter_of_prints]);\n            printf("\n\nAnd your input is ");\n            scanf("%d", &number_of_task);\n            text_arr = ft_split("\nchar    *ft_strcpy(char *s1, char *s2)\n{\n\tint i;\n\n\ti = 0;\n\twhile (s2[i])\n\t{\n\t\ts1[i] = s2[i];\n\t\ti++;\n\t}\n\ts1[i] = s2[i];\n\treturn (s1);\n}\n~int\t\tft_strlen(char *str)\n{\n\tint i;\n\n\ti = 0;\n\twhile(str[i])\n\t\ti++;\n\treturn (i);\n}\n~#include <unistd.h>\n\nint\t\tletter_count(char c)\n{\n\tint\trepeat;\n\n\tif (c >= \'A\' && c <= \'Z\')\n\t\trepeat = c - \'A\' + 1;\n\telse if (c >= \'a\' && c <= \'z\')\n\t\trepeat = c - \'a\' + 1;\n\telse\n\t\trepeat = 1;\n\treturn (repeat);\n}\n\nint\t\tmain(int ac, char **av)\n{\n\tint\trepeat;\n\n\tif (ac == 2)\n\t{\n\t\twhile (*av[1])\n\t\t{\n\t\t\trepeat = letter_count(*av[1]);\n\t\t\twhile (repeat--)\n\t\t\t\twrite(1, av[1], 1);\n\t\t\tav[1]++;\n\t\t}\n\t}\n\tft_putchar(\'\\n\');\n}\n~#include <unistd.h>\n\nint main(int argc, char **argv) {\n\tint i;\n\n\n\tif (argc != 4) {\n\t\twrite(1, \"\\n\", 1);\n\t\treturn 0;\n\t}\n\n\t\n\tif (argv[2][1] != \'\\0\' || argv[1] != \'\\0\') {\n\t\twrite(1, \"\\n\", 1);\n\t\treturn 0;\n\t}\n\n\t\n\ti = 0;\n\twhile (argv[1][i] != \'\\0\') {\n\t\tif (argv[1][i] == argv[2])\n\t\t\targv[1][i] = argv;\n\t\twrite(1, &argv[1][i], 1);\n\t\ti++;\n\t}\n\n\twrite(1, \"\\n\", 1);\n\treturn 0;\n}\n~#include <unistd.h>\n\nint\t\tmain(int ac, char **av)\n{\n\tif (ac == 2)\n\t{\n\t\twhile (*av[1])\n\t\t{\n\t\t\tif (*av[1] >= \'A\' && *av[1] <= \'Z\')\n\t\t\t{\n\t\t\t\t*av[1] += 32;\n\t\t\t\twrite(1, av[1], 1);\n\t\t\t}\n\t\t\telse if (*av[1] >= \'a\' && *av[1] <= \'z\')\n\t\t\t{\n\t\t\t\t*av[1] -= 32;\n\t\t\t\twrite(1, av[1], 1);\n\t\t\t}\n\t\t\tav[1]++;\n\t\t}\n\t}\n\twrite(1, \"\\n\", 1);\n\treturn (1);\n}\n~#include <unistd.h>\n\nvoid\tft_putchar(char c)\n{\n\twrite(1, &c, 1);\n}\n\n\nint\t\trot_13(char c)\n{\n\tif ((c >= \'A\' && c <= \'M\') || (c >= \'a\' && c <= \'m\'))\n\t\tc += 13;\n\telse if ((c >= \'N\' && c <= \'Z\') || (c >= \'n\' && c <= \'z\'))\n\t\tc -= 13;\n\treturn (c);\n}\n\n\n\nint\tmain(int ac, char **av)\n{\n\tif (ac == 2)\n\t\twhile (*av[1])\n\t\t\tft_putchar(rot_13(*av[1]++));\n\tft_putchar(\'\\n\');\n\treturn (0);\n}\n~#include <unistd.h>\n\nvoid\tft_putchar(char c)\n{\n\twrite(1, &c, 1);\n}\n\nint\t\tmain(int ac, char **av)\n{\n\tint i;\n\n\ti = 0;\n\tif (ac == 2)\n\t{\n\t\twhile (av[1][i] && (av[1][i] == \' \' || av[1][i] == \'\\t\'))\n\t\t\ti++;\n\t\twhile (av[1][i] && (av[1][i] != \' \' && av[1][i] != \'\\t\'))\n\t\t{\n\t\t\tft_putchar(av[1][i]);\n\t\t\ti++;\n\t\t}\n\t}\n\tft_putchar(\'\\n\');\n\treturn (0);\n}\n~#include <unistd.h>\n\nvoid\tft_putstr(char *str)\n{\n\twhile (*str)\n\t\twrite(1, str++, 1);\n}\n~void\tft_swap(int\t*a, int *b)\n{\n\tint temp;\n\n\ttemp = *a;\n\t*a = *b;\n\t*b = temp;\n}\n~#include <unistd.h>\n\nvoid\tft_putchar(char c)\n{\n\twrite(1, &c, 1);\n}\n\n\nint\t\tft_strlen(char *s)\n{\n\tint i;\n\n\ti = 0;\n\twhile (s[i])\n\t\ti++;\n\treturn (i);\n}\n\n\nint\t\tmain(int ac, char **av)\n{\n\tint len;\n\n\tif (ac == 2)\n\t{\n\t\tlen = ft_strlen(av[1]);\n\t\twhile (len--)\n\t\t\twrite(1, &av[1][len], 1);\n\t}\n\tft_putchar(\'\\n\');\n}\n~#include <unistd.h>\n\nvoid\tft_putchar(char c)\n{\n\twrite(1, &c, 1);\n}\n\nvoid\trotone(char *s)\n{\n\twhile (*s)\n\t{\n\t\tif ((*s >= \'A\' && *s <= \'Y\') || (*s >= \'a\' && *s <= \'y\'))\n\t\t\tft_putchar(*s + 1);\n\t\telse if (*s == \'Z\' || *s == \'z\')\n\t\t\tft_putchar(*s - 25);\n\t\telse\n\t\t\tft_putchar(*s);\n\t\t++s;\n\t}\n}\n\nint\t\tmain(int ac, char **av)\n{\n\tif (ac == 2)\n\t\trotone(av[1]);\n\tft_putchar(\'\\n\');\n\treturn (0);\n}");    \n            text = text_arr[number_of_task - 1];\n            name = headers[number_of_task - 1];\n            opener(name, text);\n        }\n        else if (level == 2)\n        {\n            headers = ft_split("ft_atoi~ft_strdup~inter~last_word~reverse_bits~swap_bits~union~alpha_mirror~max~wdmatch~do_op~print_bits~ft_strcmp~ft_strrev~is_power_of_2");\n            \n            counter_of_tasks = 14;\n            while (counter_of_prints++ != counter_of_tasks)\n                printf("%s%d.%s %s\n", YELLOW, counter_of_prints + 1, RESET, headers[counter_of_prints]);\n            printf("\n\nAnd your input is ");\n            scanf("%d", &number_of_task);\n            text_arr = ft_split("#include <stdio.h> \n\nint\t\tft_atoi(char *s)\n{\n\tint\t\tsign;\n\tlong\tr;\n\n\tr = 0;\n\tsign = 1;\n\twhile (*s == 32 || (*s >= 9 && *s <= 13))\n\t\ts++;\n\tif (*s == \'-\' || *s == \'+\')\n\t{\n\t\tif (*s == \'-\')\n\t\t\tsign = -1;\n\t\ts++;\n\t}\n\twhile (*s >= \'0\' && *s <= \'9\')\n\t{\n\t\tr = r * 10 + *s - \'0\';\n\t\ts++;\n\t}\n\treturn (sign * (int)r);\n}\n~#include <stdlib.h>\n\nchar\t*ft_strdup(char *src)\n{\n\tchar\t*s;\n\tint\t\tlen;\n\n\twhile (src[len])\n\t\t++len;\n\tif (!(s = (char *)malloc(sizeof(char) * (len + 1))))\n\t\treturn (NULL);\n\ts[len] = \'\\0\';\n\twhile (len >= 0)\n\t{\n\t\ts[len] = src[len];\n\t\tlen--;\n\t}\n\treturn (s);\n}\n~#include <unistd.h>\n\nvoid solve(char *str1, char *str2) {\n    int i;\n    int j;\n    int ascii[256] = {0};\n\n    i = 0;\n    while (str2[i])\n    {\n        if (ascii[(int)str2[i]] == 0)\n            ascii[(int)str2[i]] = 1;\n        i++;\n    }\n\n    i = 0;\n    j = 0;\n    while (str1[i])\n    {\n        if (ascii[(int)str1[i]] == 1)\n        {\n            ascii[(int)str1[i]] = 2;\n            write(1, &str1[i], 1);\n        }\n        i++;\n    }\n\n}\n\nint\tmain(int argc, char **argv) {\n\tif (argc == 3)\n\t\tsolve(argv[1], argv[2]);\n\twrite(1, \"\\n\", 1);\n\treturn 0;\n}\n~#include <unistd.h>\n\nint\t\tft_isblank(char c)\n{\n\tif (c == \' \' || c == \'\t\')\n\t\treturn (1);\n\treturn (0);\n}\n\nint\t\tmain(int ac, char **av)\n{\n\tif (ac == 2)\n\t{\n\t\twhile (*av[1])\n\t\t\tav[1]++;\n\t\tav[1]--;\n\t\twhile (ft_isblank(*av[1]))\n\t\t\tav[1]--;\n\t\twhile (*av[1] && !ft_isblank(*av[1]))\n\t\t\tav[1]--;\n\t\tav[1]++;\n\t\twhile (*av[1] && !ft_isblank(*av[1]))\n\t\t\twrite(1, av[1]++, 1);\n\t}\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n~#include <unistd.h>\n\nunsigned char reverse_bits(unsigned char b)\n{\n\tb = (b & 0xF0) >> 4 | (b & 0x0F) << 4;\n\tb = (b & 0xCC) >> 2 | (b & 0x33) << 2;\n\tb = (b & 0xAA) >> 1 | (b & 0x55) << 1;\n\treturn b;\n}\n~#include <unistd.h>\n\nunsigned char\tswap_bits(unsigned char octet)\n{\n\treturn ((octet >> 4) | (octet << 4));\n}\n~#include <unistd.h>\n\nint\t\tnot_seen_before(char *s, int max_pos, char c)\n{\n\tint i;\n\n\ti = -1;\n\twhile (++i < max_pos)\n\t\tif (s[i] == c)\n\t\t\treturn (0);\n\treturn (1);\n}\n\nvoid\tft_union(char *s1, char *s2)\n{\n\tint\ti;\n\tint j;\n\n\ti = -1;\n\twhile (s1[++i])\n\t\tif (not_seen_before(s1, i, s1[i]))\n\t\t\twrite(1, &s1[i], 1);\n\tj = -1;\n\twhile (s2[++j])\n\t\tif (not_seen_before(s1, i, s2[j]) && not_seen_before(s2, j, s2[j]))\n\t\t\twrite(1, &s2[j], 1);\n}\n\nint\t\tmain(int ac, char **av)\n{\n\tif (ac == 3)\n\t\tft_union(av[1], av[2]);\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n~#include <unistd.h>\n\nvoid\tft_putchar(char c)\n{\n\twrite(1, &c, 1);\n}\n\nint\t\tft_isalpha(char c)\n{\n\tif ((c >= \'a\' && c <= \'z\') || (c >= \'A\' && c <= \'Z\'))\n\t\treturn (1);\n\treturn (0);\n}\n\nint\t\tft_alpha_mirror(int c)\n{\n\treturn (c = (c >= \'A\' && c <= \'Z\') ? \'Z\' - (c - \'A\') : \'z\' - (c - \'a\'));\n}\n\nint\t\tmain(int ac, char **av)\n{\n\tif (ac == 2)\n\t{\n\t\twhile (*av[1])\n\t\t{\n\t\t\tif (ft_isalpha(*av[1]))\n\t\t\t\tft_putchar(ft_alpha_mirror(*(av[1]++)));\n\t\t\telse\n\t\t\t\twrite(1, av[1]++, 1);\n\t\t}\n\t}\n\twrite(1, \"\\n\", 1);\n\treturn (1);\n}\n~#include <stdio.h>\n#include <stdlib.h>\n\nint\t\tmax(int *tab, unsigned int len)\n{\n\tint\tmax;\n\n\tif (!len)\n\t\treturn (0);\n\tmax = tab[--len];\n\twhile (len--)\n\t\tif (tab[len] > max)\n\t\t\tmax = tab[len];\n\treturn (max);\n}\n~#include <unistd.h>\n\nvoid\twdmatch(char *s1, char *s2)\n{\n\tint len = 0;\n\tint i = 0;\n\n\twhile (s1[len])\n\t\t++len;\n\twhile (*s2 && i < len)\n\t\t(*s2++ == s1[i]) ? ++i : 0;\n\tif (i == len)\n\t\twrite(1, s1, len);\n}\n\nint\t\tmain(int ac, char **av)\n{\n\tif (ac == 3)\n\t\twdmatch(av[1], av[2]);\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n~#include <stdio.h>\n#include <stdlib.h>\n\nint\t\tmain(int argc, char **argv)\n{\n\tif  (argc == 4)\n\t{\n\t\tif (*argv[2] == \'+\')\n\t\t\tprintf(\"\%d\", atoi(argv[1]) + atoi(argv));\n\t\telse if (*argv[2] == \'-\')\n\t\t\tprintf(\"\%d\", atoi(argv[1]) - atoi(argv));\n\t\telse if (*argv[2] == \'*\')\n\t\t\tprintf(\"\%d\", atoi(argv[1]) * atoi(argv));\n\t\telse if (*argv[2] == \'/\')\n\t\t\tprintf(\"\%d\", atoi(argv[1]) / atoi(argv));\n\t\telse if (*argv[2] == \'\%\')\n\t\t\tprintf(\"\%d\", atoi(argv[1]) \% atoi(argv));\n\t}\n\tprintf(\"\\n\");\n\treturn (0);\n}\n~void\tprint_bits(unsigned char octet)\n{\n\tint\ti;\n\n\ti = 128;\n\twhile (octet >= 0 && i)\n\t{\n\t\t(octet / i) ? write(1, \"1\", 1) : write(1, \"0\", 1);\n\t\t(octet / i) ? octet -= i : 0;\n\t\ti /= 2;\n\t}\n}\n~int\tft_strcmp(char *s1, char *s2)\n{\n\tint i;\n\n\ti = 0;\n\twhile (s1[i] == s2[i] && s1[i] != \'\\0\' && s2[i] != \'\\0\')\n\t\ti++;\n\treturn (s1[i] - s2[i]);\n}\n~char\t*ft_strrev(char *str)\n{\n\tint\t\tcount;\n\tint\t\ti;\n\tchar\tc;\n\n\tcount = 0;\n\twhile (str[count] != \'\\0\')\n\t\tcount++;\n\tcount = count - 1;\n\ti = 0;\n\twhile (i < ((count + 1) / 2))\n\t{\n\t\tc = str[i];\n\t\tstr[i] = str[count - i];\n\t\tstr[count - i] = c;\n\t\ti++;\n\t}\n\treturn (str);\n}\n~int\t\tis_power_of_2(unsigned int n)\n{\n\tif (n == 0)\n\t\treturn (0);\n\twhile (n \% 2 == 0) \n\t\tn /= 2;\n\treturn ((n == 1) ? 1 : 0);\n}\n");\n            text = text_arr[number_of_task - 1];\n            name = headers[number_of_task - 1];\n            opener(name, text);\n        }\n        else if (level == 3)\n        {\n            headers = ft_split("add_prime_sum~epur_str~ft_list_size~ft_rrange~hidenp~pgcd~print_hex~rstr_capitalizer~expand_str~lcm~tab_mult~ft_atoi_base~ft_range~paramsum~str_capitalizer");\n            \n            counter_of_tasks = 14;\n            while (counter_of_prints++ != counter_of_tasks)\n                printf("%s%d.%s %s\n", YELLOW, counter_of_prints + 1, RESET, headers[counter_of_prints]);\n            printf("\n\nAnd your input is ");\n            scanf("%d", &number_of_task);\n            text_arr = ft_split("#include <unistd.h>\n\nvoid\tft_putchar(char c)\n{\n    \twrite(1, &c, 1);\n}\nvoid\tft_putposnbr(int n)\n{\n    \tif (n > 9)\n\t\tft_putposnbr(n / 10);\n\tft_putchar(n \% 10 + \'0\');\n}\nint\t\tft_atoi_nc(char *s)\n{\n    \tint\t\tr;\n\tr = 0;\n\twhile (*s >= \'0\' && *s <= \'9\')\n\t\tr = r * 10 + *s++ - \'0\';\n\treturn (r);\n}\nint is_prime(int n)\n{\n    \tint i;\n\ti = 2;\n\twhile (i < n)\n\t\tif (!(n \% i++))\n\t\t\treturn (0);\n\treturn (1);\n}\nvoid\tadd_prime_sum(int n)\n{\n    \tint\ti;\n\tint\tcount;\n\tcount = 0;\n\tif (n == 1)\n\t\tcount = 1;\n\ti = 1;\n\twhile (++i <= n)\n\t\tif (is_prime(i))\n\t\t\tcount += i;\n\tft_putposnbr(count);\n}\nint\t\tmain(int ac, char **av)\n{\n    \tif (ac == 2 && ft_atoi_nc(av[1]) > 0)\n\t\tadd_prime_sum(ft_atoi_nc(av[1]));\n\telse\n\t\twrite(1, \"0\", 1);\n\twrite(1, \"\\n\", 1);\n\treturn (1);\n}\n~#include <unistd.h>\n\nint\t\tft_strlen(char *s)\n{\n    \tint i;\n\ti = 0;\n\twhile (s[i])\n\t\ti++;\n\treturn (i);\n}\nint\t\tft_isblank(char c)\n{\n    \tif (c == \' \' || c == \'\\t\')\n\t\treturn (1);\n\tif (c >= 9 && c <= 13)\n\t\treturn (1);\n\treturn (0);\n}\nvoid\tepurstr(char *s)\n{\n    \tint len = ft_strlen(s);\n\twhile (len && ft_isblank(s[len - 1]))\n\t\t--len;\n\twhile (len && ft_isblank(*s) && *s++)\n\t\t--len;\n\twhile (len--)\n\t{\n    \t\tif (!ft_isblank(*s) || (*(s + 1) && !ft_isblank(*(s + 1))))\n\t\t\twrite(1, s, 1);\n\t\ts++;\n\t}\n}\nint\t\tmain(int ac, char **av)\n{\n    \tif (ac == 2 && *av[1])\n\t\tepurstr(av[1]);\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n~#include \"ft_list.h\"\n\nint\tft_list_size(t_list *begin_list)\n{\n    \tt_list\t*list;\n\tint\t\ti;\n\ti = 0;\n\tlist = begin_list;\n\twhile (list)\n\t{\n    \t\ti++;\n\t\tlist = list->next;\n\t}\n\treturn (i);\n}\n~#include <stdlib.h>\n\nint     *ft_rrange(int start, int end)\n{\n    \tint\t*r;\n\tint\tlen;\n\tlen = (end >= start) ? end - start + 1 : start - end + 1;\n\tif (!(r = (int*)malloc(sizeof(int) * len)))\n\t\treturn (NULL);\n\t while (len--)\n\t\t r[len] = (end >= start) ? start++ : start--;\n\treturn (r);\n}\n~#include <unistd.h>\n\nvoid\thidenp(char *s1, char *s2)\n{\n    \twhile (*s2)\n\t\tif (*s1 == *s2++)\n\t\t\ts1++;\n\t(*s1 == \'\\0\') ? write(1, \"1\", 1) : write(1, \"0\", 1);\n}\nint\tmain(int argc, char **argv)\n{\n    \tif (argc == 3)\n\t\thidenp(argv[1], argv[2]);\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n~#include <stdio.h>\n#include <stdlib.h>\n\nint\t\tpgcd(unsigned int nb, unsigned int nb2)\n{\n    \tint i;\n\ti = nb;\n\twhile (i > 0)\n\t{\n    \t\tif (nb \% i == 0 && nb2 \% i == 0)\n\t\t\treturn (i);\n\t\ti--;\n\t}\n\treturn (1);\n}\nint\tmain(int argc, char **argv)\n{\n    \tif (argc == 3)\n\t\tprintf(\"\%d\", pgcd(atoi(argv[1]), atoi(argv[2])));\n\tprintf(\"\\n\");\n\treturn (0);\n}\n~#include <unistd.h>\n\nint\t\tft_atoi(char *s)\n{\n    \tlong\tr;\n\tint\t\tsign;\n\twhile (*s == 32 || (*s >= 9 && *s <= 13))\n\t\ts++;\n\tsign = (*s == \'-\') ? -1 : 1;\n\t(*s == \'-\' || *s == \'+\') ? s++ : s;\n\tr = 0;\n\twhile (*s >= \'0\' && *s <= \'9\')\n\t\tr = r * 10 + *s++ - \'0\';\n\treturn ((int)r * sign);\n}\nvoid\tprint_hex(int n)\n{\n    \tif (n >= 16)\n\t\tprint_hex(n / 16);\n\tn = n \% 16;\n\tn += n < 10 ? \'0\' : \'a\' - 10;\n\twrite(1, &n, 1);\n}\nint\t\tmain(int ac, char **av)\n{\n    \tif (ac == 2)\n\t\tprint_hex(ft_atoi(av[1]));\n\twrite(1, \"\\n\", 1);\n\treturn (1);\n}\n~#include <unistd.h>\n\nvoid\tft_putchar(char c)\n{\n    \twrite(1, &c, 1);\n}\nvoid\trstr_capitalizer(int argc, char **argv)\n{\n    \tint i;\n\tint j;\n\ti = 1;\n\tj = 0;\n\twhile (i < argc)\n\t{\n    \t\tj = 0;\n\t\twhile (argv[i][j] != \'\\0\')\n\t\t{\n    \t\t\tif (argv[i][j] >= \'A\' && argv[i][j] <= \'Z\' )\n\t\t\t\targv[i][j] += 32;\n\t\t\tif (argv[i][j + 1] == \' \' || argv[i][j + 1] == \'\\t\' || argv[i][j + 1] == \'\\0\')\n\t\t\t{\n    \t\t\t\tif (argv[i][j] >= \'a\' && argv[i][j] <= \'z\')\n\t\t\t\t\targv[i][j] -= 32;\n\t\t\t}\n\t\t\tft_putchar(argv[i][j]);\n\t\t\tj++;\n\t\t}\n\t\tft_putchar(\'\\n\');\n\t\ti++;\n\t}\n}\nint\t\tmain(int argc, char **argv)\n{\n    \tif (argc > 1)\n\t\trstr_capitalizer(argc, argv);\n\telse\n\t\tft_putchar(\'\\n\');\n\treturn (0);\n}\n~#include <unistd.h>\n\nint\t\tft_isblank(char c)\n{\n    \treturn ((c == \' \' || c == \'\\t\') ? 1 : 0);\n}\nvoid\texpand_str(char *s)\n{\n    \tint\ti = 0;\n\tint\twc = 0;\n\twhile (s[i])\n\t\tif (!ft_isblank(s[i++]) && (!wc || ft_isblank(s[i - 2])))\n\t\t\t++wc;\n\ti = 0;\n\twhile (s[i])\n\t{\n    \t\tif (!ft_isblank(s[i++]) && wc--)\n\t\t{\n    \t\t\twrite (1, &s[i - 1], 1);\n\t\t\twhile (s[i] && !ft_isblank(s[i]) && write(1, &s[i++], 1));\n\t\t\t(wc) ? write(1, \"   \", 3) : 0;\n\t\t}\n\t}\n}\nint\t\tmain(int ac, char **av)\n{\n    \tif (ac == 2)\n\t\texpand_str(av[1]);\n\twrite(1, \"\\n\", 1);\n}\n \n~unsigned int    lcm(unsigned int a, unsigned int b)\n{\n        unsigned int    d;\n    if (!a || !b)\n        return (0);\n    if (a > b)\n        d = (a / 2) + 1;\n    else\n        d = (b / 2) + 1;\n    while (!((a \% d) == 0 && (b \% d) == 0))\n        d--;\n    return (a * b / d);\n}\n~#include <unistd.h>\n\nvoid\tft_putchar(char c)\n{\n    \twrite(1, &c, 1);\n}\nvoid\tft_putposnbr(int n)\n{\n    \tif (n > 9)\n\t\tft_putposnbr(n / 10);\n\tft_putchar(n \% 10 + \'0\');\n}\nint\t\tft_atoi_osefvalid(char *s)\n{\n    \tint\t\tr;\n\tr = 0;\n\twhile (*s >= \'0\' && *s <= \'9\')\n\t\tr = r * 10 + *s++ - \'0\';\n\treturn (r);\n}\nvoid\ttab_mult(int n)\n{\n    \tint i = 1;\n\twhile (i < 10)\n\t{\n    \t\tft_putposnbr(i);\n\t\twrite(1,\" x \", 3);\n\t\tft_putposnbr(n);\n\t\twrite(1, \" = \", 3);\n\t\tft_putposnbr(i++ * n);\n\t\twrite(1, \"\\n\", 1);\n\t}\n}\nint\t\tmain(int ac, char **av)\n{\n    \tif (ac == 2)\n\t\ttab_mult(ft_atoi_osefvalid(av[1]));\n\telse\n\t\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n~int isblank(char c)\n{\n    \tif (c <= 32)\n\t\treturn (1);\n\treturn (0);\n}\nint\t\tisvalid(char c, int base)\n{\n    \tchar digits[17] = \"0123456789abcdef\";\n\tchar digits2[17] = \"0123456789ABCDEF\";\n\twhile (base--)\n\t\tif (digits[base] == c || digits2[base] == c)\n\t\t\treturn (1);\n\treturn (0);\n}\nint\t\tvalue_of(char c)\n{\n    \tif (c >= \'0\' && c <= \'9\')\n\t\treturn (c - \'0\');\n\telse if (c >= \'a\' && c <= \'f\')\n\t\treturn (c - \'a\' + 10);\n\telse if (c >= \'A\' && c <= \'F\')\n\t\treturn (c - \'A\' + 10);\n\treturn (0);\n}\nint\t\tft_atoi_base(const char *str, int str_base)\n{\n    \tint result;\n\tint sign;\n\tresult = 0;\n\twhile (isblank(*str))\n\t\tstr++;\n\tsign = (*str == \'-\') ? -1 : 1;\n\t(*str == \'-\' || *str == \'+\') ? ++str : 0;\n\twhile (isvalid(*str, str_base))\n\t\tresult = result * str_base + value_of(*str++);\n\treturn (result * sign);\n}\n~#include <stdlib.h>\n\nint\t\t*ft_range(int min, int max)\n{\n    \tint\t\tn;\n\tint\t\t*s;\n\tn = max >= min ? max - min : min - max;\n\tif (!(s = (int *)malloc(sizeof(int) * (n))))\n\t\treturn (NULL);\n\twhile (max != min)\n\t\t*s++ = max > min ? min++ : min--;\n\t*s = min;\n\treturn (s - n);\n}\n~#include <unistd.h>\n\nvoid\tft_putchar(char c)\n{\n    \twrite(1, &c, 1);\n}\nvoid\tft_putnbr(int n)\n{\n    \tif (n > 9)\n\t\tft_putnbr(n / 10);\n\tft_putchar(n \% 10 +\'0\');\n}\nint\t\tmain(int ac, char **av)\n{\n    \tav = 0;\n\tft_putnbr(ac - 1);\n\twrite(1, \"\\n\", 1);\n}\n~#include <unistd.h>\n\nvoid\tft_putchar(char c)\n{\n    \twrite(1, &c, 1);\n}\nint\t\tft_isspace(char c)\n{\n    \tif (c == \' \' || c == \'\\t\')\n\t\treturn (1);\n\treturn (0);\n}\nint\t\ttolower(char c)\n{\n    \treturn (c += (c >= \'A\' && c <= \'Z\') ? 32 : 0);\n}\nint\t\ttoupper(char c)\n{\n    \treturn (c -= (c >= \'a\' && c <= \'z\') ? 32 : 0);\n}\nvoid\tstr_capitaliser(char *s)\n{\n    \twhile (*s)\n\t{\n    \t\twhile (ft_isspace(*s))\n\t\t\tft_putchar(*s++);\n\t\tif (*s && !ft_isspace(*s))\n\t\t\tft_putchar(toupper(*s++));\n\t\twhile (*s && !ft_isspace(*s))\n\t\t\tft_putchar(tolower(*s++));\n\t}\n}\nint\t\tmain(int ac, char **av)\n{\n    \tif (ac > 1)\n\t{\n    \t\t++av;\n\t\twhile (*av)\n\t\t{\n    \t\t\tstr_capitaliser(*av++);\n\t\t\twrite(1, \"\\n\", 1);\n\t\t}\n\t}\n\treturn (0);\n}");\n            text = text_arr[number_of_task - 1];\n            name = headers[number_of_task - 1];\n            opener(name, text);\n        }\n        else if (level == 4)\n        {\n            headers = ft_split("ft_list_remove_if~sort_list~ft_itoa~ft_itoa_base~brainfuck~flood_fill~fprime~ft_list_foreach~ft_split~rev_wstr~rostring~sort_int_tab");\n            \n            counter_of_tasks = 11;\n            while (counter_of_prints++ != counter_of_tasks)\n                printf("%s%d.%s %s\n", YELLOW, counter_of_prints + 1, RESET, headers[counter_of_prints]);\n            printf("\n\nAnd your input is ");\n            scanf("%d", &number_of_task);\n            text_arr = ft_split("#include <stdlib.h>\n#include \"ft_list.h\"\n\nvoid\tft_list_remove_if(t_list **begin_list, void *data_ref, int (*cmp)())\n{\n    \tt_list\t*curr;\n\tt_list\t*tmp;\n\n\twhile (*begin_list && cmp((*begin_list)->data, data_ref) == 0)\n\t{\n    \t\tcurr = *begin_list;\n\t\t*begin_list = (*begin_list)->next;\n\t\tfree(curr);\n\t}\n\tcurr = *begin_list;\n\twhile (curr && curr->next)\n\t{\n    \t\tif (cmp(curr->next->data, data_ref) == 0)\n\t\t{\n    \t\t\ttmp = curr->next;\n\t\t\tcurr->next = tmp->next;\n\t\t\tfree(tmp);\n\t\t}\n\t\tcurr = curr->next;\n\t}\n}\n~#include <stdlib.h>\n#include <stdio.h>\n#include \"list.h\"\n\nvoid\tswap(int *a, int *b)\n{\n    \tint\ttmp;\n\n\ttmp = *a;\n\t*a = *b;\n\t*b = tmp;\n}\n\n\nint\t\tascending(int a, int b)\n{\n    \t\treturn (a <= b);\n}\n\nt_list\t\t*sort_list(t_list* lst, int (*cmp)(int, int))\n{\n    \tt_list\t*begin;\n\tt_list\t*p;\n\n\tbegin = lst;\n\twhile (lst)\n\t{\n    \t\tp = lst->next;\n\t\twhile (p)\n\t\t{\n    \t\t\tif (!(*cmp)(lst->data, p->data))\n\t\t\t{\n    \t\t\t\tswap(&lst->data, &p->data);\n\t\t\t}\n\t\t\tp = p->next;\n\t\t}\n\t\tlst = lst->next;\n\t}\n\treturn (begin);\n}\n~#include <stdlib.h>\n\nstatic int\tft_strlen(const char *s)\n{\n    \tint i;\n\n\ti = 0;\n\twhile (s[i])\n\t\ti++;\n\treturn i;\n}\n\nstatic char\t*ft_strrev(char *str)\n{\n    \tint i;\n\tint j;\n\tint tmp;\n\n\ti = 0;\n\tj = ft_strlen(str);\n\twhile (j > i)\n\t{\n    \t\tj--;\n\t\ttmp = str[i];\n\t\tstr[i] = str[j];\n\t\tstr[j] = tmp;\n\t\ti++;\n\t}\n\treturn str;\n}\n\nchar\t*ft_itoa(int nbr)\n{\n    \tint i;\n\tint neg;\n\tchar *tmp;\n\n\ti = 0;\n\tneg = 0;\n\ttmp = malloc(sizeof(char) * 12);\n\tif (tmp == NULL || nbr == 0)\n\t\treturn ((nbr == 0) ? \"0\" : NULL);\n\tif (nbr == -2147483648)\n\t\treturn (\"-2147483648\");\n\tif (nbr < 0)\n\t{\n    \t\tneg = 1;\n\t\tnbr *= -1;\n\t}\n\twhile (nbr)\n\t{\n    \t\ttmp[i++] = (nbr \% 10) + \'0\';\n\t\tnbr /= 10;\n\t}\n\tif (neg)\n\t\ttmp[i] = \'-\';\n\treturn ft_strrev(tmp);\n}\n~#include <stdlib.h>\n\nchar\t*ft_itoa_base(int value, int base)\n{\n    \tchar\t*s;\n\tlong\tn;\n\tint\t\tsign;\n\tint\t\ti;\n\n\tn = (value < 0) ? -(long)value : value;\n\tsign = (value < 0 && base == 10) ? -1 : 0;\n\ti = (sign == -1) ? 2 : 1;\n\twhile ((n /= base) >= 1)\n\t\ti++;\n\ts = (char*)malloc(sizeof(char) * (i + 1));\n\ts[i] = \'\\0\';\n\tn = (value < 0) ? -(long)value : value;\n\twhile (i-- + sign)\n\t{\n    \t\ts[i] = (n \% base < 10) ? n \% base + \'0\' : n \% base + \'A\' - 10;\n\t\tn /= base;\n\t}\n\t(i == 0) ? s[i] = \'-\' : 0;\n\treturn (s);\n}\n~#include <unistd.h>\n\nint\t\tgo_to_matching(char *operations, int curr)\n{\n    \tint balance = 0;\n\n\tif (operations[curr] == \'[\')\n\t{\n    \t\tcurr++;\n\t\twhile (!(operations[curr] == \']\' && balance == 0))\n\t\t{\n    \t\t\tif (operations[curr] == \'[\')\n\t\t\t\tbalance++;\n\t\t\telse if (operations[curr] == \']\')\n\t\t\t\tbalance--;\n\t\t\tcurr++;\n\t\t}\n\t\tcurr--;\n\t}\n\telse if (operations[curr] == \']\')\n\t{\n    \t\tcurr--;\n\t\twhile (!(operations[curr] == \'[\' && balance == 0))\n\t\t{\n    \t\t\tif (operations[curr] == \']\')\n\t\t\t\tbalance++;\n\t\t\telse if (operations[curr] == \'[\')\n\t\t\t\tbalance--;\n\t\t\tcurr--;\n\t\t}\n\t\tcurr--;\n\t}\n\treturn (curr);\n}\n\nvoid\tfuck_brain(char *operations)\n{\n    \tint curr = 0;\n\tint pointer = 0;\n\tchar bytes[2048];\n\n\twhile (curr < 2048)\n\t\tbytes[curr++] = 0;\n\n\tcurr = 0;\n\twhile (operations[curr])\n\t{\n    \t\tif (operations[curr] == \'>\')\n\t\t\tpointer++;\n\t\telse if (operations[curr] == \'<\')\n\t\t\tpointer--;\n\t\telse if (operations[curr] == \'+\')\n\t\t\tbytes[pointer]++;\n\t\telse if (operations[curr] == \'-\')\n\t\t\tbytes[pointer]--;\n\t\telse if (operations[curr] == \'.\')\n\t\t\twrite(1, &bytes[pointer], 1);\n\t\telse if (operations[curr] == \'[\')\n\t\t{\n    \t\t\tif (bytes[pointer] == 0)\n\t\t\t\tcurr = go_to_matching(operations, curr);\n\t\t}\n\t\telse if (operations[curr] == \']\')\n\t\t{\n    \t\t\tif (bytes[pointer] != 0)\n\t\t\t\tcurr = go_to_matching(operations, curr);\n\t\t}\n\t\tcurr++;\n\t}\n}\n\nint\t\tmain(int ac, char **av)\n{\n    \tif (ac == 2)\n\t\tfuck_brain(av[1]);\n\telse\n\t\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n~typedef struct\ts_point\n{\n    \tint\t\t\tx;\n\tint\t\t\ty;\n}\t\t\t\tt_point;\n\nvoid flood_fill(char **tab, t_point size, t_point begin)\n{\n    \tchar\tc;\n\n\tc = tab[begin.y][begin.x];\n\ttab[begin.y][begin.x] = \'F\';\n\tif ((begin.x + 1 < size.x) && (tab[begin.y][begin.x + 1] == c))\n\t\tflood_fill(tab, size, (t_point){begin.x + 1, begin.y});\n\tif (begin.x > 0 && (tab[begin.y][begin.x - 1] == c))\n\t\tflood_fill(tab, size, (t_point){begin.x - 1, begin.y});\n\tif ((begin.y + 1 < size.y) && (tab[begin.y + 1][begin.x] == c))\n\t\tflood_fill(tab, size, (t_point){begin.x, begin.y + 1});\n\tif (begin.y > 0 && (tab[begin.y - 1][begin.x] == c))\n\t\tflood_fill(tab, size, (t_point){begin.x, begin.y - 1});\n}\n~#include <stdlib.h>\n#include <stdio.h>\n\nvoid\tfprime(unsigned int nb)\n{\n    \tunsigned int\tprime;\n\n\tif (nb == 1)\n\t\tprintf(\"1\");\n\telse\n\t{\n    \t\tprime = 2;\n\t\twhile (nb > 1)\n\t\t{\n    \t\t\tif (nb \% prime == 0)\n\t\t\t{\n    \t\t\t\tprintf(\"\%d\", prime);\n\t\t\t\tnb /= prime;\n\t\t\t\tif (nb > 1)\n\t\t\t\t\tprintf(\"*\");\n\t\t\t\tprime--;\n\t\t\t}\n\t\t\tprime++;\n\t\t}\n\t}\n}\n\nint\t\tmain(int ac, char **av)\n{\n    \tif (ac == 2 && *av[1])\n\t\tfprime(atoi(av[1]));\n\tprintf(\"\\n\");\n\treturn (0);\n}\n~#include \"ft_list.h\"\n\nvoid\tft_list_foreach(t_list *begin_list, void (*f)(void *))\n{\n    \tt_list\t*curr;\n\n\tcurr = begin_list;\n\twhile (curr)\n\t{\n    \t\t(*f)(curr->data);\n\t\tcurr = curr->next;\n\t}\n}\n~#include <stdlib.h>\n\nint\t\t\tft_isspace(char c)\n{\n    \treturn (c == \' \' || c == \'\\n\' || c == \'\\t\');\n}\n\nint\t\tcount_words(char *str)\n{\n    \tint\tcount;\n\n\tcount = 0;\n\twhile (*str)\n\t{\n    \t\twhile (*str && ft_isspace(*str))\n\t\t\tstr++;\n\t\tif (*str && !ft_isspace(*str))\n\t\t{\n    \t\t\tcount++;\n\t\t\twhile (*str && !ft_isspace(*str))\n\t\t\t\tstr++;\n\t\t}\n\t}\n\treturn (count);\n}\n\nchar\t*malloc_word(char *str)\n{\n    \tchar *word;\n\tint\ti;\n\n\ti = 0;\n\twhile (str[i] && !ft_isspace(str[i]))\n\t\ti++;\n\tword = (char *)malloc(sizeof(char) * (i + 1));\n\ti = 0;\n\twhile (str[i] && !ft_isspace(str[i]))\n\t{\n    \t\tword[i] = str[i];\n\t\ti++;\n\t}\n\tword[i] = \'\\0\';\n\treturn (word);\n}\n\nchar\t**ft_split(char *str)\n{\n    \tchar **arr = (char **)malloc(sizeof(char *) * (count_words(str) + 1));\n\tint i = 0;\n\twhile (*str)\n\t{\n    \t\twhile (*str && ft_isspace(*str))\n\t\t\tstr++;\n\t\tif (*str && !ft_isspace(*str))\n\t\t{\n    \t\t\tarr[i] = malloc_word(str);\n\t\t\ti++;\n\t\t\twhile (*str && !ft_isspace(*str))\n\t\t\t\tstr++;\n\t\t}\n\t}\n\tarr[i] = NULL;\n\treturn (arr);\n}\n~#include <unistd.h>\n\nint\t\tstr_length(char *str)\n{\n    \tint\tlen = 0;\n\n\twhile (*str)\n\t{\n    \t\tstr++;\n\t\tlen++;\n\t}\n\treturn (len);\n}\n\nint\t\tiswhitespace(char chr)\n{\n    \treturn (chr == \' \' || chr == \'\\t\');\n}\n\nvoid\tprint_reverse(char *str)\n{\n    \tint fast;\n\tint slow;\n\tint curr;\n\n\tfast = str_length(str) - 1;\n\tslow = fast;\n\tcurr = fast;\n\n\twhile (fast >= 0)\n\t{\n    \t\tslow = fast;\n\t\tcurr = fast;\n\t\twhile (fast >= 0 && !iswhitespace(str[fast]))\n\t\t\tfast--;\n\t\tfast++;\n\t\tcurr = fast;\n\t\twhile (curr <= slow)\n\t\t{\n    \t\t\twrite(1, &str[curr], 1);\n\t\t\tcurr++;\n\t\t}\n\t\tif (fast > 0)\n\t\t\twrite(1, \" \", 1);\n\t\tfast--;\n\t\tfast--;\n}\n}\nint\t\tmain(int ac, char **av)\n{\n    \tif (ac == 2)\n\t\tprint_reverse(av[1]);\n\twrite(1, \"\\n\", 1);\n\treturn (1);\n}\n~#include <unistd.h>\n\nint\t\tft_isblank(char c)\n{\n    \treturn (c == \' \' || c == \'\\t\');\n}\n\nvoid\trostring(char *s)\n{\n    \tint\t\ti = 0;\n\tint\t\tfirst_word_length = 0;\n\n\twhile (s[i])\n\t{\n    \t\twhile (ft_isblank(s[i]))\n\t\t\ti++;\n\t\tif (s[i] && !ft_isblank(s[i]))\n\t\t{\n    \t\t\tif (first_word_length == 0)\n\t\t\t\twhile (s[i] && !ft_isblank(s[i++]))\n\t\t\t\t\tfirst_word_length++;\n\t\t\telse\n\t\t\t{\n    \t\t\t\twhile (s[i] && !ft_isblank(s[i]) && write(1, &s[i++], 1));\n\t\t\t\twrite(1, \" \", 1);\n\t\t\t}\n\t\t}\n\t}\n\n\ti = 0;\n\twhile (ft_isblank(s[i]))\n\t\ti++;\n\twhile (first_word_length--)\n\t\twrite(1, &s[i++], 1);\n}\n\nint\t\tmain(int ac, char **av)\n{\n    \tif (ac > 1 && *av[1])\n\t\trostring(av[1]);\n\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n~void\tswap_elements(int *tab, unsigned int p1, unsigned int p2)\n{\n    \tint tmp = tab[p1];\n\ttab[p1] = tab[p2];\n\ttab[p2] = tmp;\n}\n\nvoid\tbubble_sort(int *tab, unsigned int size)\n{\n    \tunsigned int i = 0;\n\tunsigned int j = 0;\n\n\twhile (i < size)\n\t{\n    \t\tj = 0;\n\t\twhile (j < size - 1)\n\t\t{\n    \t\t\tif (tab[j] > tab[j + 1])\n\t\t\t\tswap_elements(tab, j, j + 1);\n\t\t\tj++;\n\t\t}\n\t\ti++;\n\t}\n}\n\nvoid\tsort_int_tab(int *tab, unsigned int size)\n{\n    \tif (size <= 1)\n\t\treturn ;\n\tbubble_sort(tab, size);\n}\n");\n            name = headers[number_of_task - 1];\n            text = text_arr[number_of_task - 1];\n            opener(name, text);\n        }\n        else if (level == 5)\n        {\n            headers = ft_split("check_mate~print_memory~brackets~rpn_calc~options~cycle_detector~biggest_pal");\n            printf("\n\nAttention! Some of tasks can be failed, please check it rigorously\nCompile it with main.c before pushing\n");\n            printf("Peak %sprint_memory%s, %srpn_calc%s, %soptions%s or %scycle-detector%s - this tasks won't be failed 100\n\n", RED, RESET, RED, RESET, RED, RESET, RED, RESET);\n            \n            counter_of_tasks = 6;\n            while (counter_of_prints++ != counter_of_tasks)\n                printf("%s%d.%s %s\n", YELLOW, counter_of_prints + 1, RESET, headers[counter_of_prints]);\n            printf("\n\nAnd your input is ");\n            scanf("%d", &number_of_task);\n            text_arr = ft_split("#include <stdlib.h>\n#include <unistd.h>\n\nint\t\tcheckmate(int ac, char **av)\n{\n\tint\t\ty = 0;\n\tint\t\tx = 0;\n\tint\t\tlen = 0;\n\tint\t\tb = 0;\n\tint\t\ta = 0;\n\tchar\t**m;\n\n\twhile (ac-- > 1)\n\t\tlen++;\n\tif (!(m = (char **)malloc(sizeof(char *) * len * (len + 1))))\n\t\treturn (0);\n\ty = 0;\n\twhile (y < len)\n\t{\n\t\tif (!(m[y] = (char *)malloc(sizeof(char) * (len + 1))))\n\t\t\treturn (0);\n\t\tx = 0;\n\t\twhile (av[y + 1][x])\n\t\t{\n\t\t\tm[y][x] = av[y + 1][x];\n\t\t\tif (m[y][x] == \'K\')\n\t\t\t{\n\t\t\t\ta = x;\n\t\t\t\tb = y;\n\t\t\t}\n\t\t\t++x;\n\t\t}\n\t\tm[y][x] = 0;\n\t\t++y;\n\t}\n\n\tif (m[b + 1][a + 1] == \'P\' || m[b + 1][a - 1] == \'P\')\n\t\treturn (0);\n\n\tint\t\ti = 0;\n\twhile (i < len)\n\t{\n\t\tif (m[b][i] == \'Q\' || m[i][a] == \'Q\' || m[b][i] == \'R\' || m[i][a] == \'R\')\n\t\t\treturn (0);\n\t\tif (i < b)\n\t\t{\n\t\t\tif (i < a && (m[b - i - 1][a - i - 1] == \'B\' || m[b - i - 1][a - i - 1] == \'Q\') )\n\t\t\t\treturn (0);\n\t\t\tif (a + i < len && (m[b - i - 1][a + i + 1] == \'B\' || m[b - i - 1][a + i + 1] == \'Q\'))\n\t\t\t\treturn (0);\n\t\t}\n\t\tif (b + i < len)\n\t\t{\n\t\t\tif (i < a && (m[b + i + 1] [a - i - 1] == \'B\' || m[b + i + 1] [a - i - 1] == \'Q\'))\n\t\t\t\treturn (0);\n\t\t\tif (a + i < len && (m[b + i + 1] [a + i + 1] == \'B\' || m[b + i + 1] [a + i + 1] == \'Q\' ))\n\t\t\t\treturn (0);\n\t\t}\n\t\ti++;\n\t}\n\treturn (1);\n}\n\n\nvoid\tprint(int ac, char **av)\n{\t\n\tint\t\tlen;\n\tint\t\tx;\n\tint\t\ty;\n\tchar\t**m;\n\n\twhile (ac-- > 1)\n\t\tlen++;\n\tif (!(m = (char **)malloc(sizeof(char *) * len * (len + 1))))\n\t\treturn ;\n\ty = 0;\n\twhile (y < len)\n\t{\n\t\tif (!(m[y] = (char *)malloc(sizeof(char) * (len + 1))))\n\t\t\treturn ;\n\t\tx = 0;\n\t\twhile (av[y + 1][x])\n\t\t{\n\t\t\tm[y][x] = av[y + 1][x];\n\t\t\t++x;\n\t\t}\n\t\tm[y][x] = 0;\n\t\t++y;\n\t}\n\ty = 0;\n\twhile (y < len)\n\t{\n\t\twrite(1, m[y++], len);\n\t\twrite(1, \"\\n\", 1);\n\t}\n}\n\n\nint\t\tmain(int ac, char **av)\n{\n\tif (ac > 1 && checkmate(ac, av))\n\t\twrite(1, \"Success\\n\", 8);\n\telse\n\t\twrite(1, \"Fail\\n\", 5);\n\tprint(ac, av);\n\treturn (0);\n}\n91939~#include <unistd.h>\n#include <stdio.h>\n\nvoid\tft_putchar(char c)\n{\n\twrite(1, &c, 1);\n}\n\nvoid\tft_putasci(unsigned char c)  \n{\n\tif (c >= 32 && c < 127)\n\t\tft_putchar(c);\n\telse\n\t\tft_putchar(\'.\');\n}\n\nvoid \tft_puthex(unsigned char c)  \n{\n\tchar tab[16] = \"0123456789abcdef\";\n\n\tft_putchar(tab[c / 16]);\n\tft_putchar(tab[c \% 16]);\n}\n\nvoid\tft_printline(unsigned char *temp, size_t start, size_t max) \n{\n\tsize_t\ti;\n\n\ti = start;\n\twhile (i < (start + 16) && i < max)  \n\t{\n\t\tft_puthex(temp[i]);\n\t\tif (i \% 2 != 0)\n\t\t\tft_putchar(\' \');\n\t\ti++;\n\t}\n\twhile (i < (start + 16))\n\t{\n\t\tft_putchar(\' \');\n\t\tft_putchar(\' \');\n\t\tif (i \% 2 != 0)\n\t\t\tft_putchar(\' \');\n\t\ti++;\n\t}\n\ti = start;\n\twhile (i < (start + 16) && i < max)  \n\t{\n\t\tft_putasci(temp[i]);\n\t\ti++;\n\t}\n\tft_putchar(\'\\n\');\n}\n\nvoid\tprint_memory(const void *addr, size_t size)\n{\n\tunsigned char  *temp;\n\tsize_t\t\t\ti;\n\n\ttemp = (unsigned char *)addr;\n\ti = 0;\n\twhile (i < size)\n\t{\n\t\tft_printline(temp, i, size);\n\t\ti = i + 16;\n\t}\n}~91939#include <unistd.h>\n\nint\tbraclose(char *str, char c, int i, int b)\n{\n\twhile (b && *(++str) && (i++))\n\t\tif (*str == c || *str == c + c \% 2 + 1)\n\t\t\t*str == c ? ++b : --b;\n\treturn (i);\n}\n\nint\tbrackets(char *str, char c)\n{\n\tif (*str == c)\n\t\treturn (1);\n\telse if (!*str || *str == \')\' || *str == \'}\' || *str == \']\')\n\t\treturn (0);\n\telse if (*str == \'(\' || *str == \'{\' || *str == \'[\')\n\t\treturn (brackets(str + 1, *str + *str \% 2 + 1)\n\t\t\t* brackets(str + braclose(str, *str, 1, 1), c));\n\telse\n\t\treturn (brackets(str + 1, c));\n}\n\nint\tmain(int ac, char **av)\n{\n\tint\ti;\n\n\ti = 0;\n\tif (ac > 1)\n\t\twhile (++i < ac)\n\t\t\tbrackets(av[i], 0) ? write(1, \"OK\\n\", 3) : write(1, \"Error\\n\", 6);\n\telse\n\t\twrite(1, \"\\n\", 1);\n\treturn (0);\n}\n~#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nint\t\tft_strlen(char *str)\n{\n\tint\t\ti;\n\n\ti = 0;\n\twhile (str[i] != \'\\0\')\n\t\ti++;\n\treturn (i);\n}\n\nint\t\tft_isdigit(char c)\n{\n\tif (c >= \'0\' && c <= \'9\')\n\t\treturn (1);\n\treturn (0);\n}\n\nint\t\tis_operateur(char *str)\n{\n\tint\t\ti;\n\n\ti = 0;\n\tif (str[i] == \'*\' || str[i] == \'+\' || str[i] == \'-\' || str[i] == \'\%\' || str[i] == \'/\')\n\t{\n\t\tif (ft_isdigit(str[i + 1]) == 0)\n\t\t\treturn (1);\n\t}\n\treturn (0);\n}\n\nlong\t\t*rpn_calc(char *str)\n{\n\tlong\t*tab;\n\tint\t\ti;\n\tint\t\tj;\n\t\t\n\ti = 0;\n\tj = 0;\n\tif (!(tab = (long*)malloc(sizeof(long) * ft_strlen(str))))\n\t\treturn (NULL);\n\twhile (str[i] != \'\\0\')\n\t{\n\t\twhile (is_operateur(str + i) == 0)\n\t\t{\n\t\t\ttab[j] = atoi(str + i);\n\t\t\tj++;\n\t\t\twhile (str[i] != \'\\0\' && str[i] != \' \')\n\t\t\t\ti++;\n\t\t\tif (str[i] == \'\\0\')\n\t\t\t{\n\t\t\t\tprintf(\"Error\\n\");\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\twhile (str[i] == \' \')\n\t\t\t\ti++;\n\t\t}\n\t\tif (j < 2)\n\t\t{\n\t\t\tprintf(\"Error\\n\");\n\t\t\treturn (NULL);\n\t\t}\n\t\tif (str[i] == \'/\')\n\t\t{\n\t\t\tif (tab[j - 1] == 0)\n\t\t\t{\n\t\t\t\tprintf(\"Error\\n\");\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\ttab[j - 2] = tab[j - 2] / tab[j - 1];\n\t\t}\n\t\telse if (str[i] == \'-\')\n\t\t\ttab[j - 2] = tab[j - 2] - tab[j - 1];\n\t\telse if (str[i] == \'+\')\n\t\t\ttab[j - 2] = tab[j - 2] + tab[j - 1];\n\t\telse if (str[i] == \'*\')\n\t\t\ttab[j - 2] = tab[j - 2] * tab[j - 1];\n\t\telse if (str[i] == \'\%\')\n\t\t{\n\t\t\tif (tab[j - 1] == 0)\n\t\t\t{\n\t\t\t\tprintf(\"Error\\n\");\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\ttab[j - 2] = tab[j - 2] \% tab[j - 1];\n\t\t}\n\t\tj--;\n\t\ti++;\n\t\twhile (str[i] == \' \')\n\t\t\ti++;\n\t}\n\tif (j > 1)\n\t{\n\t\tprintf(\"Error\\n\");\n\t\treturn (NULL);\n\t}\n\treturn (tab);\n}\n\nint\t\tmain(int argc, char **argv)\n{\n\tlong\t*tab;\n\n\tif (argc == 2 && argv[1] != \'\\0\')\n\t{\n\t\ttab = rpn_calc(argv[1]);\n\t\tif (tab != NULL)\n\t\t\tprintf(\"\%ld\\n\", *tab);\n\t\treturn (0);\n\t}\n\tprintf(\"Error\\n\");\n\treturn (0);\n}\n~#include <unistd.h>\n\nint main(int ac, char **av)\n{\n\tint i = 1;\n\tint  t[32] = {0}; \n\tint j ;\n\n\tif(ac == 1)\n\t{\n\t\twrite(1,\"options: abcdefghijklmnopqrstuvwxyz\\n\",36);\n\t\treturn 0;\n\t}\n\ti = 1;\n\twhile (i < ac)\n\t{\n\t\tj = 1;\n\t\tif(*av[i] == \'-\')\n\t\t{\n\t\t\twhile(av[i][j] && av[i][j] >= \'a\'  && av[i][j] <= \'z\')\n\t\t\t{\n\t\t\t\tif(av[i][j] == \'h\')\n\t\t\t\t{\n\t\t\t\t\twrite(1,\"options: abcdefghijklmnopqrstuvwxyz\\n\",36);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\tt[\'z\' - av[i][j] + 6] = 1;\n\t\t\t\tj++;\n\t\t\t}\n\n\t\t\tif (av[i][j])\n\t\t\t{\n\t\t\t\twrite(1,\"Invalid Option\\n\",15);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\ti++;\n\t}\n\ti = 0;\n\t\twhile (i < 32)\n\t\t{\n\t\tt[i] = \'0\' + t[i];\n\t\twrite(1,&t[i++],1);\n\t\t\tif(i == 32)\n\t\t\t\twrite(1,\"\\n\",1);\n\t\t\telse if(i \% 8 == 0)\n\t\t\t\twrite(1,\" \",1);\n\n\t\t}\n\n\treturn 0;\n}\n~#include \"list.h\"\n\nint        cycle_detector(const t_list *list)\n{\n\tconst t_list\t*slow;\n\tconst t_list\t*fast;\n\n\tslow = list;\n\tfast = list;\n\tif (!list)\n\t\treturn (0);\n\twhile (fast && fast->next)\n\t{\n\t\tslow = slow->next;\n\t\tfast = fast->next->next;\n\t\tif (fast == slow)\n\t\t\treturn (1);\n\t}\n\treturn (0);\n}\n~#include <unistd.h>\n\nvoid print_pal(char* str, int low, int high)\n{\n\twhile (low <= high)\n\t\twrite(1, &str[low++], 1);\n}\n\nvoid biggest_pal(char *str)\n{\n\tint\ti;\n\tint len;\n\tint low;\n\tint high;\n\tint max_len;\n\tint start;\n\n\tlen = 0;\n\twhile (str[len])\n\t\tlen++;\n\ti = 1;\n\tmax_len = 1;\n\twhile (++i < len)\n\t{ \n\t\tlow = i - 1;\n\t\thigh = i;\n\t\twhile (low >= 0 && high < len && str[low] == str[high])\n\t\t{\n\t\t\tif (high - low + 1 > max_len)\n\t\t\t{\n\t\t\t\tstart = low;\n\t\t\t\tmax_len = high - low + 1;\n\t\t\t}\n\t\t\t--low;\n\t\t\t++high;\n\t\t}\n\t\tlow = i - 1;\n\t\thigh = i + 1;\n\t\twhile (low >= 0 && high < len && str[low] == str[high])\n\t\t{\n\t\t\tif (high - low + 1 > max_len)\n\t\t\t{\n\t\t\t\tstart = low;\n\t\t\t\tmax_len = high - low + 1;\n\t\t\t}\n\t\t\t--low;\n\t\t\t++high;\n\t\t}\n\t}\n\tprint_pal(str, start, start + max_len - 1);\n}\n\nint main(int argc, char **argv)\n{\n\tif (argc == 2)\n\t\tbiggest_pal(argv[1]);\n\twrite(1, \"\\n\", 1);\n\treturn 0;\n}");\n            name = headers[number_of_task - 1];\n            text = text_arr[number_of_task - 1];\n            opener(name, text);\n        }\n    } \n    return 0;\n}